(()=>{var e={154:(e,t,r)=>{var n=r(969).Buffer;e.exports=class{constructor(e){this.scripts=new Map,e&&this.addContent(e)}addContent(e){for(const[t,r]of Object.entries(e))this.addScript(t,r)}addScript(t,{content:r,world:i,runAt:o}){this.scripts.set(t,{content:r,world:i,runAt:o})}get enabled(){return this.scripts.size>0}eval(e,t){const r=[],i=[],o=[];for(const e of this.scripts.values())"main"===e.world?r.push(e.content):"isolated"===e.world?i.push(e.content):"page"===e.world&&o.push(e.content);const s=e=>n.from(e).toString("base64");return`
      ((${e.toString()})({
        pageScripts: [${o.map((e=>`{
            content: \`${s(e)}\`,
            runAt: 'document_start'
          }`)).join(",\n")}
        ],
        isolatedWorldScripts: [${i.map((e=>`{
            content: \`${s(e)}\`,
            runAt: 'document_start'
          }`)).join(",\n")}
        ],
        mainWorldScripts: [${r.map((e=>`{
            content: \`${s(e)}\`,
            runAt: 'document_start'
          }`)).join(",\n")}
        ],
      }, ${JSON.stringify(t) ||"{}"}));
    `}}}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{r.r(n),r.d(n,{default:()=>u,generateStealth:()=>a});const e=[{name:"chrome.runtime",script:`
(() => {
  if (!window.chrome) {
    // Use the exact property descriptor found in headful Chrome
    // Fetching the property descriptor dynamically avoids making assumptions about it.
    // That said, properties are unlikely to change in upcoming Chrome versions.
    const document = window.document;
    const script = document.createElement('script');
    script.textContent = \`
      Object.defineProperty(window, 'chrome', {
        configurable: false,
        enumerable: true,
        value: {},
        writable: true
      })
    \`;
    document.head.appendChild(script);
    script.remove();
  }

  // That's literally all we need for funcaptcha to work \`_Â´
  const makeMethod = ({name, isAsync, fn}) => {
    const method = isAsync
      ? async (...args) => fn(...args)
      : (...args) => fn(...args)
    Object.defineProperty(method, 'name', { value: name, configurable: true });
    return method
  }

  const STATIC_DATA = {
    "csi": {
      "fn": {
        "startE": 1615326322363,
        "pageT": 1615326322363,
        "tran": 15
      },
      "bin": {
        "CSI": {
          "tran": 15,
          "pageT": 1615326322363,
          "startE": 1615326322363
        }
      }
    },
    "loadTimes": {
      "fn": {
        "requestTime": 1615326322031.519,
        "startLoadTime": 1615326322031.519,
        "commitLoadTime": 1615326322340.54,
        "finishLoadTime": 1615326322839.203,
        "finishDocumentLoadTime": 1615326322748.985,
        "firstPaintTime": 1615326322407.5,
        "firstPaintAfterLoadTime": 0
      },
      "bin": {
        "load": {
          "requestTime": 1615326322031.519,
          "startLoadTime": 1615326322031.519,
          "commitLoadTime": 1615326322340.54,
          "finishLoadTime": 1615326322839.203,
          "finishDocumentLoadTime": 1615326322748.985,
          "firstPaintTime": 1615326322407.5,
          "firstPaintAfterLoadTime": 0
        }
      }
    }
  }

  // Handle messaging
  const postMessage = makeMethod({
    name: 'postMessage',
    isAsync: true,
    fn: function postMessage(message, options) {
      // Funfact: This is not a real event in headful Chrome, it's generated by the browser itself.
      window.dispatchEvent(
        new MessageEvent('message', {
          data: message
        })
      )
    }
  })

  // Mock chrome.runtime
  window.chrome.runtime = {
    // For funcaptcha
    ...STATIC_DATA,
    // For hcaptcha
    postMessage
  };

  // Mock chrome.csi, etc
  for (const key of Object.keys(STATIC_DATA)) {
    if (key in window.chrome) {
      continue
    }
    window.chrome[key] = STATIC_DATA[key].fn;
  }
})()
`},{name:"navigator.languages",script:e=>{void 0===e.languages||e.languages.length||(e.languages=["en-US","en"])},options:{languages:[]}},{name:"navigator.permissions",script:`
(() => {
  const originalQuery = window.navigator.permissions.query;
  window.navigator.permissions.query = (parameters) =>
    parameters.name === 'notifications'
      ? Promise.resolve(Object.setPrototypeOf({ state: 'prompt' }, Notification.prototype))
      : originalQuery(parameters);

  // Inspired by: https://github.com/ikarienator/phantomjs-qunit/blob/master/qunit/qunit.js#L239
  const oldCall = Function.prototype.call;
  function call() {
    return oldCall.apply(this, arguments);
  }
  Function.prototype.call = call;

  const nativeToString = Function.prototype.toString;
  function toString() {
    if (this === window.navigator.permissions.query) {
      return 'function query() { [native code] }';
    }
    return nativeToString.apply(this, arguments);
  }
  Function.prototype.toString = toString;
})()
`},{name:"navigator.plugins",script:`
(utils) => {
  /**
   * In headful on a new profile, navigator.plugins is a empty array.
   *
   * On Windows, headful chrome will have 3 default plugins:
   * - "PDF Viewer"
   * - "Chrome PDF Viewer"
   * - "Native Client"
   *
   * On MacOS, headful chrome will have 5 default plugins:
   * - "QuickTime Plug-in"
   * - "Shockwave Flash"
   * - "iPhotoPhotocast"
   * - "SharePoint Browser Plug-in"
   * - "Google Talk Plugin"
   */
  const MIMETYPE_DATA = [{
    type: 'application/pdf',
    suffixes: 'pdf',
    description: 'Portable Document Format'
  }, {
    type: 'application/x-google-chrome-pdf',
    suffixes: 'pdf',
    description: 'Portable Document Format'
  }, {
    type: 'application/x-nacl',
    suffixes: '',
    description: 'Native Client Executable'
  }, {
    type: 'application/x-pnacl',
    suffixes: '',
    description: 'Portable Native Client Executable'
  }]
  const PLUGIN_DATA = [{
    name: 'Chrome PDF Viewer',
    filename: 'internal-pdf-viewer',
    description: 'Portable Document Format'
  }, {
    name: 'Chrome PDF Viewer',
    filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai',
    description: 'Portable Document Format'
  }, {
    name: 'Native Client',
    filename: 'internal-nacl-plugin',
    description: ''
  }]

  const getPluginArray = () => {
    const arr = []
    for (const p of PLUGIN_DATA) {
      arr.push(utils.newPlugin(p))
    }
    // arr.push(undefined)
    return arr
  }
  const getMimeTypeArray = () => {
    const arr = []
    for (const m of MIMETYPE_DATA) {
      arr.push(utils.newMimeType(m))
    }
    return arr
  }

  const mimeTypes = getMimeTypeArray()
  const plugins = getPluginArray()

  // All of this is only necessary to make 'in' and 'for...in' work as expected
  const MimeTypeArray = function() {
    throw new TypeError('Illegal constructor')
  }
  const PluginArray = function() {
    throw new TypeError('Illegal constructor')
  }

  // Create prototypes for our custom MimeTypeArray and PluginArray interfaces
  const mimeTypeArrayProto = Object.create(MimeTypeArray.prototype)
  const pluginArrayProto = Object.create(PluginArray.prototype)

  // Bypassing 'Illegal constructor' with some trickery
  const myMimeTypes = Object.create(mimeTypeArrayProto)
  const myPlugins = Object.create(pluginArrayProto)

  // And finally we're back to making sure 'in' and 'for...in' work as expected
  // It's important to set these before the indexed properties
  Object.defineProperty(myMimeTypes, 'length', {
    value: mimeTypes.length,
    writable: false,
    enumerable: false,
    configurable: true // Important to be able to use in, for...in
  })
  Object.defineProperty(myPlugins, 'length', {
    value: plugins.length,
    writable: false,
    enumerable: false,
    configurable: true // Important to be able to use in, for...in
  })

  for (let i = 0; i < mimeTypes.length; i++) {
    myMimeTypes[i] = mimeTypes[i]
    Object.defineProperty(myMimeTypes, mimeTypes[i].type, {
      value: mimeTypes[i],
      writable: false,
      enumerable: false,
      configurable: true
    })
  }
  for (let i = 0; i < plugins.length; i++) {
    myPlugins[i] = plugins[i]
    Object.defineProperty(myPlugins, plugins[i].name, {
      value: plugins[i],
      writable: false,
      enumerable: false,
      configurable: true
    })
  }

  utils.replaceGetterWithProxy(
    navigator,
    'mimeTypes',
    myMimeTypes
  )
  utils.replaceGetterWithProxy(
    navigator,
    'plugins',
    myPlugins
  )
}
`},{name:"navigator.webdriver",script:e=>{e&&delete e.webdriver}},{name:"user-agent-override",script:(e,{userAgent:t})=>{try{Object.defineProperty(navigator,"userAgent",{get:()=>t})}catch(e){}},options:{userAgent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"}},{name:"utils",script:`
(utils) => {
  utils.init = () => {
    utils.preloadCache()
  }

  utils.preloadCache = () => {
    if (utils.cache) {
      return
    }
    utils.cache = {
      // Used in our proxies
      Reflect: {
        get: Reflect.get,
        apply: Reflect.apply
      },
      // Used in \`makeNativeString\`
      nativeToStringStr: Function.toString.toString()
    }
  }

  utils.makeNativeString = (name = '') => {
    return utils.cache.nativeToStringStr.replace('toString', name || '')
  }

  utils.patchToString = (obj, str = '') => {
    const handler = {
      apply: function (target, thisArg, args) {
        // These checks determine if the toString() was called organically
        if (thisArg instanceof obj) {
          return str
        }
        // Strict equality check which contains the constructors toString function
        if (thisArg === obj) {
          return str
        }
        // All other scenarios, just call the original toString()
        return utils.cache.Reflect.apply(target, thisArg, args)
      }
    }
    utils.replaceWithProxy(obj, 'toString', handler)
  }

  utils.patchToStringNested = (obj = {}) => {
    return utils.execRecursively(obj, ['function'], utils.patchToString)
  }

  utils.replaceWithProxy = (obj, propName, handler) => {
    const originalObj = obj[propName]
    const proxyObj = new Proxy(obj[propName], handler)

    utils.redefineProperty(obj, propName, { value: proxyObj })
    return originalObj
  }

  utils.replaceGetterWithProxy = (obj, propName, proxyObj) => {
    const fn = Object.getOwnPropertyDescriptor(obj, propName).get
    const fnStr = fn.toString()
    const patchedFn = fnStr.replace(
      /\{\s*\[native code\]\s*\}/,
      \`{ return utils.cache.Reflect.apply(arguments.callee, this, arguments) }\`
    )
    const proxyFn = new Proxy(eval(\`(\${patchedFn})\`), {
      apply: function (target, thisArg, args) {
        // We need to find the correct context to apply the proxy
        if (thisArg instanceof obj.constructor) {
          return proxyObj
        }
        return utils.cache.Reflect.apply(target, thisArg, args)
      }
    })
    utils.redefineProperty(obj, propName, { get: proxyFn })
  }

  /**
   * Everything below is copied from the original puppeteer-extra-plugin-stealth repo
   */

  utils.newMimeType = (data) => {
    const mimeType = {}
    // Need to create a custom toString function, otherwise it will be \`[object Object]\`
    mimeType.toString = () => '[object MimeType]'

    // The plugin needs to be "connected" to the mimeType
    const plugin = utils.newPlugin(data)
    mimeType.enabledPlugin = plugin

    // All properties are not enumerable
    Object.defineProperty(mimeType, 'type', {
      value: data.type,
      writable: false,
      enumerable: false,
      configurable: true
    })
    Object.defineProperty(mimeType, 'suffixes', {
      value: data.suffixes,
      writable: false,
      enumerable: false,
      configurable: true
    })
    Object.defineProperty(mimeType, 'description', {
      value: data.description,
      writable: false,
      enumerable: false,
      configurable: true
    })
    Object.defineProperty(mimeType, 'enabledPlugin', {
      value: plugin,
      writable: false,
      enumerable: false,
      configurable: true
    })

    // mimeTypes must have an indexed property, otherwise it's not a MimeTypeArray
    mimeType[0] = plugin
    return mimeType
  }

  utils.newPlugin = (data) => {
    const plugin = {}
    // Need to create a custom toString function, otherwise it will be \`[object Object]\`
    plugin.toString = () => '[object Plugin]'

    // All properties are not enumerable
    Object.defineProperty(plugin, 'name', {
      value: data.name,
      writable: false,
      enumerable: false,
      configurable: true
    })
    Object.defineProperty(plugin, 'filename', {
      value: data.filename,
      writable: false,
      enumerable: false,
      configurable: true
    })
    Object.defineProperty(plugin, 'description', {
      value: data.description,
      writable: false,
      enumerable: false,
      configurable: true
    })
    return plugin
  }

  utils.redefineProperty = (obj, prop, descriptor) => {
    // Note: This is a bit of a given since we need to re-define a property
    descriptor.configurable = true
    Object.defineProperty(obj, prop, descriptor)
  }
}
`,world:"isolated"},{name:"window.outerdimensions",script:`
(() => {
  try {
    if (window.outerWidth && window.outerHeight) {
      return;
    }
    const windowFrame = 85; // Probably OS and WM dependent
    window.outerWidth = window.innerWidth;
    window.outerHeight = window.innerHeight + windowFrame;
  } catch (err) {}
})()
`}];const t=`
/**
 * This is the main entry point for the stealth plugin.
 *
 * The stealth plugin is a wrapper around the functionality of this file.
 *
 * @see https://github.com/berstend/puppeteer-extra/tree/master/packages/puppeteer-extra-plugin-stealth
 */
((utils, opts) => {
  // All entry points should be called in order.
  // We don't use \`map\` here to make sure the scripts are executed in order.
  for (const script of opts.scripts) {
    // The script can be a function or a string.
    // If it's a function, it's a factory that expects \`utils\` and \`opts\`.
    if (typeof script.fn === 'function') {
      script.fn(utils, opts)
    } else {
      // The script is a string, so we need to eval it.
      // With this we can just pass a string to the script.
      // The script can be a function or a string.
      // We need to wrap the script in a function to be able to call it.
      // We need to use eval here, otherwise we would not be able to pass
      // the \`utils\` and \`opts\` objects to the script.
      // eslint-disable-next-line no-eval
      eval(\`(() => {
        const fn = (utils, opts) => {
          ${script.fn}
        }
        fn(utils, opts)
      })()\`)
    }
  }
})
`,i=r(154);const o=[{name:"chrome.runtime",world:"main"},{name:"navigator.languages",world:"main"},{name:"navigator.permissions",world:"main"},{name:"navigator.plugins",world:"isolated"},{name:"navigator.webdriver",world:"main"},{name:"user-agent-override",world:"main"},{name:"utils",world:"isolated"},{name:"window.outerdimensions",world:"main"}];class s extends i{constructor(t={}){super();const r=o.map((r=>Object.assign(r,e.find((e=>e.name===r.name))))).map((e=>({name:e.name,content:e.script.toString(),world:e.world,runAt:"document_start"})));for(const e of r)this.addScript(e.name,e)}}const a=function(e={}){const r=new s(e).eval(t,e);return r},u={generate:a}})()})();

//# sourceMappingURL=index.js.map
`
